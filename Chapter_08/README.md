# Chapter 08. 상수

- 변하지 않는 값을 표현할 때 사용

- 자주 사용되는, 변경되지 않는 숫자값이나 문자열값에 주로 사용

---

## 08-I. 상수 선언

- 상수: 변하지 않는 값. 초기화된 값 변하지 않음.
    - 정수, 실수, 문자열 등의 기본 타입들primitive만 상수로 선언 가능
    - 구조체, 배열 등 complex에는 상수 사용 불가 
    - boolean, rune, 정수, 실수, 복소수, 문자열 가능

- 변수: 대입문을 통해 값을 수시로 바꿀 수 있음.


- `선언 방식`
    - var과 비슷
    - var 대신 **const** 키워드 이용
    
```go
const ConstValue int = 10
```

값으로만 동작하기 때문에 대입문의 좌변에 올 수 없음

---

## 08-II. 상수를 사용할 때

변하면 안 되는 값에 사용, 코드값을 통해 숫자에 의미를 부여할 때 사용

### 08-II-a. 변하면 안 되는 값에 사용

pie처럼 고정 불변의 것일 때 사용

### 08-II-b. 코드값으로 사용

- 상수를 코드값으로 사용 가능
    - ex. ASCII 문자 코드, HTTP 응답 코드
    

- 숫자값에 의미를 부여하는 코드로 처리하면 더욱 편리

### 08-III-c. `iota`로 간편하게 열거값 사용

코드값이 1씩 증가하도록 할 때 `iota` 키워드 이용하면 편리

- `iota`
    - 0부터 시작해 1씩 증가
    - 소괄호를 벗어나면 다시 초기화
    

```go
const {
    Red int = iota // 0
    Blue int = iota // 1
    Green int = iota // 2
}
```

아래 예제는 C2에서 타입과 iota 생략했기 때문에 C1과 마찬가지로 C2 uint = iota + 1로 적용됨

```go
const {
    C1 uint = iota + 1 // 1 = 0 + 1
    C2 // 2 = 1 + 1
    C3 // 3 = 2 + 1
```

혹은 아래와 같이 쓸 수도 있음

```go
const {
    BitFlag1 unit = 1 << iota // 1 = 1 << 0
    BitFlag2 // 2 = 1 << 1
    BitFlag3 // 4 = 1 << 2
    BitFlag4 // 8 = 1 << 3
}

const {
    A int = iota // 0
    B // 1
}
```

---

## 8-III. 타입 없는 상수

상수 선언 시 타입 명시하지 않으면 타입 없는 상수가 됨.

타입 없는 상수는 타입이 정해지지 않은 상태로 사용됨

---

## 8- IV. 상수와 리터럴

- `리터럴`: 고정된 값, 값 자체로 쓰인 문구

```go
var str string = "Hello World"
var i int = 0
i = 30
```

"Hello World", 0, 30과 같이 고정된 값 자체로 쓰인 문구가 리터럴임

- Go에서 상수는 리터럴과 함께 취급
    - 컴파일 시 상수는 리터럴로 변환되어 실행 파일에 쓰임
    

```go
const PI = 3.14
var a int = PI * 100
```

위 코드는 컴파일 타임에 아래처럼 변환됨

```go
var a int = 314
```

---

## 연습 문제

1.

> const Gravity = 9.80665


2.

> 2, 3
